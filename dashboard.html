<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Heartbit Daemon Dashboard</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; background: #0d1117; color: #c9d1d9; padding: 16px; }
  h1 { color: #58a6ff; font-size: 18px; margin-bottom: 12px; }
  h2 { color: #8b949e; font-size: 13px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; border-bottom: 1px solid #21262d; padding-bottom: 4px; }

  .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px; }
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }

  .card { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 12px; }
  .card.healthy { border-left: 3px solid #3fb950; }
  .card.unhealthy { border-left: 3px solid #f85149; }
  .card.pending { border-left: 3px solid #d29922; }

  .stat { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 4px; }
  .stat-label { color: #8b949e; font-size: 11px; }
  .stat-value { color: #f0f6fc; font-size: 16px; font-weight: bold; }
  .stat-value.green { color: #3fb950; }
  .stat-value.red { color: #f85149; }
  .stat-value.yellow { color: #d29922; }
  .stat-value.blue { color: #58a6ff; }

  .events-log { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; height: 360px; overflow-y: auto; padding: 8px; font-size: 11px; line-height: 1.6; }
  .events-log .event { padding: 2px 0; border-bottom: 1px solid #21262d; }
  .events-log .ts { color: #484f58; }
  .events-log .type { font-weight: bold; }
  .events-log .type.run_started { color: #58a6ff; }
  .events-log .type.turn_started { color: #8b949e; }
  .events-log .type.llm_response { color: #a371f7; }
  .events-log .type.tool_call_started { color: #d29922; }
  .events-log .type.tool_call_completed { color: #3fb950; }
  .events-log .type.run_completed { color: #3fb950; }
  .events-log .type.run_failed { color: #f85149; }
  .events-log .type.sub_agents_dispatched { color: #79c0ff; }
  .events-log .type.sub_agent_completed { color: #56d364; }
  .events-log .detail { color: #8b949e; margin-left: 8px; }

  .tasks-table { width: 100%; border-collapse: collapse; font-size: 11px; }
  .tasks-table th { color: #8b949e; text-align: left; padding: 4px 8px; border-bottom: 1px solid #30363d; font-weight: normal; text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; }
  .tasks-table td { padding: 4px 8px; border-bottom: 1px solid #21262d; }
  .tasks-table .state-running { color: #58a6ff; }
  .tasks-table .state-completed { color: #3fb950; }
  .tasks-table .state-failed { color: #f85149; }
  .tasks-table .state-pending { color: #d29922; }

  .metrics-raw { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; max-height: 200px; overflow-y: auto; padding: 8px; font-size: 10px; line-height: 1.5; color: #8b949e; white-space: pre; }

  .source-badge { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px; }
  .source-badge.api { background: #1f2937; color: #58a6ff; }
  .source-badge.telegram { background: #1f2937; color: #a371f7; }
  .source-badge.ws { background: #1f2937; color: #d29922; }
  .source-badge.cron { background: #1f2937; color: #8b949e; }
  .source-badge.sensor { background: #1f2937; color: #3fb950; }
  .source-badge.heartbit { background: #1f2937; color: #f85149; }

  .agent-pill { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px; background: #1c2128; color: #79c0ff; margin: 1px 2px; }

  .grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px; }
  .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px; }

  .sensor-bar { display: flex; height: 6px; border-radius: 3px; overflow: hidden; background: #21262d; margin-top: 4px; }
  .sensor-bar .bar-received { background: #58a6ff; }
  .sensor-bar .bar-promoted { background: #3fb950; }
  .sensor-bar .bar-dropped { background: #484f58; }
  .sensor-event { padding: 3px 0; border-bottom: 1px solid #21262d; font-size: 11px; }
  .sensor-event .sensor-name { color: #3fb950; font-weight: bold; }
  .sensor-event .sensor-ts { color: #484f58; }
  .sensor-event .sensor-content { color: #c9d1d9; }
  .sensor-event .sensor-verdict { font-size: 10px; padding: 1px 5px; border-radius: 3px; margin-left: 4px; }
  .sensor-event .sensor-verdict.promoted { background: #0d2818; color: #3fb950; }
  .sensor-event .sensor-verdict.dropped { background: #1c1315; color: #8b949e; }

  #connection-status { position: fixed; top: 8px; right: 16px; font-size: 11px; padding: 4px 8px; border-radius: 4px; }
  #connection-status.connected { background: #0d1117; color: #3fb950; border: 1px solid #3fb950; }
  #connection-status.disconnected { background: #0d1117; color: #f85149; border: 1px solid #f85149; }

  .submit-bar { display: flex; gap: 8px; margin-bottom: 16px; }
  .submit-bar input { flex: 1; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 8px 12px; color: #c9d1d9; font-family: inherit; font-size: 13px; }
  .submit-bar input:focus { outline: none; border-color: #58a6ff; }
  .submit-bar button { background: #238636; border: none; border-radius: 6px; color: white; padding: 8px 16px; cursor: pointer; font-family: inherit; font-size: 13px; }
  .submit-bar button:hover { background: #2ea043; }
</style>
</head>
<body>

<h1>&#x2764; Heartbit Daemon Dashboard</h1>
<div id="connection-status" class="disconnected">disconnected</div>

<div class="submit-bar">
  <input id="task-input" type="text" placeholder="Submit a task to the daemon..." />
  <button onclick="submitTask()">Submit</button>
</div>

<div class="grid-4">
  <div class="card" id="health-card">
    <h2>Health</h2>
    <div class="stat"><span class="stat-label">Status</span><span class="stat-value" id="health-status">--</span></div>
    <div class="stat"><span class="stat-label">Uptime</span><span class="stat-value" id="health-uptime">--</span></div>
    <div class="stat"><span class="stat-label">Kafka</span><span class="stat-value" id="health-kafka">--</span></div>
  </div>
  <div class="card">
    <h2>Tasks</h2>
    <div class="stat"><span class="stat-label">Total</span><span class="stat-value blue" id="m-total">0</span></div>
    <div class="stat"><span class="stat-label">Active</span><span class="stat-value yellow" id="m-active">0</span></div>
    <div class="stat"><span class="stat-label">Completed</span><span class="stat-value green" id="m-completed">0</span></div>
    <div class="stat"><span class="stat-label">Failed</span><span class="stat-value red" id="m-failed">0</span></div>
  </div>
  <div class="card">
    <h2>LLM</h2>
    <div class="stat"><span class="stat-label">Calls</span><span class="stat-value" id="m-llm-calls">0</span></div>
    <div class="stat"><span class="stat-label">Input tokens</span><span class="stat-value" id="m-llm-input">0</span></div>
    <div class="stat"><span class="stat-label">Output tokens</span><span class="stat-value" id="m-llm-output">0</span></div>
    <div class="stat"><span class="stat-label">Cost (USD)</span><span class="stat-value green" id="m-llm-cost">$0.00</span></div>
  </div>
  <div class="card">
    <h2>Sources</h2>
    <div id="source-breakdown" style="font-size: 11px; color: #8b949e;">No tasks yet</div>
  </div>
</div>

<div class="grid-3">
  <div class="card">
    <h2>Sensors</h2>
    <div class="stat"><span class="stat-label">Events received</span><span class="stat-value blue" id="m-sensor-received">0</span></div>
    <div class="stat"><span class="stat-label">Promoted</span><span class="stat-value green" id="m-sensor-promoted">0</span></div>
    <div class="stat"><span class="stat-label">Dropped</span><span class="stat-value" id="m-sensor-dropped" style="color:#484f58">0</span></div>
    <div class="stat"><span class="stat-label">Active stories</span><span class="stat-value yellow" id="m-sensor-stories">0</span></div>
    <div class="sensor-bar" id="sensor-bar"><div class="bar-promoted" style="width:0%"></div><div class="bar-dropped" style="width:0%"></div></div>
  </div>
  <div class="card">
    <h2>Sensor Sources</h2>
    <div id="sensor-sources" style="font-size: 11px; color: #8b949e;">No sensor events yet</div>
  </div>
  <div class="card">
    <h2>Sensor Activity</h2>
    <div id="sensor-activity" class="events-log" style="height: 140px;"></div>
  </div>
</div>

<div class="grid">
  <div class="card">
    <h2>Agents</h2>
    <div id="agent-stats" style="font-size: 11px; color: #8b949e;">No agent runs yet</div>
  </div>
  <div class="card">
    <h2>Tools</h2>
    <div id="tool-stats" style="font-size: 11px; color: #8b949e;">No tool calls yet</div>
  </div>
  <div class="card">
    <h2>Reliability</h2>
    <div class="stat"><span class="stat-label">Retries</span><span class="stat-value" id="m-retries">0</span></div>
    <div class="stat"><span class="stat-label">Doom loops</span><span class="stat-value" id="m-doom">0</span></div>
    <div class="stat"><span class="stat-label">Compactions</span><span class="stat-value" id="m-compactions">0</span></div>
    <div class="stat"><span class="stat-label">Guardrail denials</span><span class="stat-value" id="m-guardrails">0</span></div>
    <div class="stat"><span class="stat-label">Session prunes</span><span class="stat-value" id="m-prunes">0</span></div>
    <div class="stat"><span class="stat-label">Summarizations</span><span class="stat-value" id="m-summarizations">0</span></div>
  </div>
</div>

<div class="grid-2">
  <div>
    <h2>Live Events</h2>
    <div class="events-log" id="events-log"></div>
  </div>
  <div>
    <h2>Tasks</h2>
    <div style="max-height: 360px; overflow-y: auto;">
      <table class="tasks-table" id="tasks-table">
        <thead><tr><th>ID</th><th>Source</th><th>State</th><th>Task</th><th>Tokens</th><th>Cost</th></tr></thead>
        <tbody id="tasks-body"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
const BASE = 'http://127.0.0.1:7777';
let sseConnections = {};

function fmt(n) { return n >= 1000 ? (n/1000).toFixed(1) + 'k' : String(n); }
function fmtTime(s) { return s >= 3600 ? (s/3600).toFixed(1) + 'h' : s >= 60 ? (s/60).toFixed(0) + 'm' : s.toFixed(0) + 's'; }

// --- Health polling ---
async function pollHealth() {
  try {
    const [hz, rz] = await Promise.all([
      fetch(BASE + '/healthz').then(r => r.json()).catch(() => null),
      fetch(BASE + '/readyz').then(r => r.json()).catch(() => null),
    ]);
    const card = document.getElementById('health-card');
    const status = document.getElementById('health-status');
    const uptime = document.getElementById('health-uptime');
    const kafka = document.getElementById('health-kafka');
    const conn = document.getElementById('connection-status');

    if (hz) {
      status.textContent = hz.status;
      status.className = 'stat-value ' + (hz.status === 'ok' ? 'green' : 'red');
      uptime.textContent = fmtTime(hz.uptime_seconds || 0);
      card.className = 'card ' + (hz.status === 'ok' ? 'healthy' : 'unhealthy');
      conn.textContent = 'connected';
      conn.className = 'connected';
    } else {
      status.textContent = 'unreachable';
      status.className = 'stat-value red';
      card.className = 'card unhealthy';
      conn.textContent = 'disconnected';
      conn.className = 'disconnected';
    }
    if (rz && rz.checks) {
      const kc = rz.checks.find(c => c.name === 'kafka');
      kafka.textContent = kc && kc.ok ? 'connected' : 'down';
      kafka.className = 'stat-value ' + (kc && kc.ok ? 'green' : 'red');
    }
  } catch(e) {
    document.getElementById('connection-status').textContent = 'disconnected';
    document.getElementById('connection-status').className = 'disconnected';
  }
}

// --- Metrics polling ---
function parsePrometheus(text) {
  const m = {};
  for (const line of text.split('\n')) {
    if (line.startsWith('#') || !line.trim()) continue;
    const match = line.match(/^([a-zA-Z_:][a-zA-Z0-9_:]*?)(\{[^}]*\})?\s+(.+)$/);
    if (match) {
      const [, name, labels, val] = match;
      const key = name + (labels || '');
      m[key] = parseFloat(val);
    }
  }
  return m;
}

// Sum all label variants for a metric name, e.g. heartbit_llm_calls_total{agent="x"} + {agent="y"}
function sumMetric(m, prefix) {
  let total = 0;
  for (const [k, v] of Object.entries(m)) {
    if (k === prefix || k.startsWith(prefix + '{')) total += v;
  }
  return total;
}

// Extract label values: extractLabel(m, 'heartbit_agent_runs_started_total', 'agent') → {analyst: 2, ...}
function extractLabel(m, prefix, labelName) {
  const result = {};
  const re = new RegExp(`^${prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\{.*?${labelName}="([^"]+)".*\\}$`);
  for (const [k, v] of Object.entries(m)) {
    const match = k.match(re);
    if (match) result[match[1]] = (result[match[1]] || 0) + v;
  }
  return result;
}

async function pollStats() {
  try {
    const stats = await fetch(BASE + '/stats').then(r => r.json());
    document.getElementById('m-total').textContent = fmt(stats.total_tasks || 0);
    document.getElementById('m-active').textContent = fmt(stats.active_tasks || 0);
    document.getElementById('m-completed').textContent = fmt((stats.tasks_by_state || {}).completed || 0);
    document.getElementById('m-failed').textContent = fmt((stats.tasks_by_state || {}).failed || 0);

    // Source breakdown
    const srcDiv = document.getElementById('source-breakdown');
    const sources = stats.tasks_by_source || {};
    if (Object.keys(sources).length > 0) {
      srcDiv.innerHTML = Object.entries(sources)
        .sort((a,b) => b[1] - a[1])
        .map(([src, cnt]) => `<div class="stat"><span class="stat-label"><span class="source-badge ${src}">${src}</span></span><span class="stat-value">${cnt}</span></div>`)
        .join('');
    } else {
      srcDiv.textContent = 'No tasks yet';
    }
  } catch(e) {}
}

async function pollMetrics() {
  try {
    const text = await fetch(BASE + '/metrics').then(r => r.text());
    const m = parsePrometheus(text);

    // LLM stats (aggregated across agent labels)
    document.getElementById('m-llm-calls').textContent = fmt(sumMetric(m, 'heartbit_llm_calls_total'));
    document.getElementById('m-llm-input').textContent = fmt(sumMetric(m, 'heartbit_llm_tokens_input_total'));
    document.getElementById('m-llm-output').textContent = fmt(sumMetric(m, 'heartbit_llm_tokens_output_total'));
    const cost = sumMetric(m, 'heartbit_llm_cost_usd_total');
    document.getElementById('m-llm-cost').textContent = '$' + cost.toFixed(4);

    // Sensors
    const sensorReceived = sumMetric(m, 'heartbit_sensor_events_received_total');
    const sensorDropped = sumMetric(m, 'heartbit_sensor_events_dropped_total');
    const sensorPromoted = Math.max(0, sensorReceived - sensorDropped);
    const sensorStories = m['heartbit_sensor_stories_active'] || 0;

    document.getElementById('m-sensor-received').textContent = fmt(sensorReceived);
    document.getElementById('m-sensor-promoted').textContent = fmt(Math.max(0, sensorPromoted));
    document.getElementById('m-sensor-dropped').textContent = fmt(sensorDropped);
    document.getElementById('m-sensor-stories').textContent = sensorStories;

    // Sensor bar
    if (sensorReceived > 0) {
      const pPct = Math.max(0, sensorPromoted) / sensorReceived * 100;
      const dPct = sensorDropped / sensorReceived * 100;
      const bar = document.getElementById('sensor-bar');
      bar.innerHTML = `<div class="bar-promoted" style="width:${pPct}%" title="${Math.max(0,sensorPromoted)} promoted"></div><div class="bar-dropped" style="width:${dPct}%" title="${sensorDropped} dropped"></div>`;
    }

    // Per-source breakdown
    const sensorSources = extractLabel(m, 'heartbit_sensor_events_received_total', 'sensor_name');
    const sensorDroppedBySource = extractLabel(m, 'heartbit_sensor_events_dropped_total', 'sensor_name');
    const srcEl = document.getElementById('sensor-sources');
    if (Object.keys(sensorSources).length > 0) {
      srcEl.innerHTML = Object.entries(sensorSources)
        .sort((a,b) => b[1] - a[1])
        .map(([name, recv]) => {
          const drop = sensorDroppedBySource[name] || 0;
          const prom = Math.max(0, recv - drop);
          const dropPct = recv > 0 ? Math.min(100, Math.round(drop / recv * 100)) : 0;
          return `<div class="stat" style="margin-bottom:6px">
            <span class="stat-label"><span class="source-badge sensor">${name}</span></span>
            <span style="font-size:11px"><span style="color:#3fb950">${prom}</span> / ${recv} <span style="color:#484f58">(${dropPct}% filtered)</span></span>
          </div>`;
        }).join('');
    } else {
      srcEl.textContent = 'No sensor events yet';
    }

    // Sensor activity log — show triage counts as they change
    updateSensorActivity(sensorSources, sensorDroppedBySource);

    // Reliability
    document.getElementById('m-retries').textContent = m['heartbit_reliability_retry_attempts_total'] || 0;
    document.getElementById('m-doom').textContent = m['heartbit_reliability_doom_loops_detected_total'] || 0;
    document.getElementById('m-compactions').textContent = m['heartbit_reliability_context_compactions_total'] || 0;
    document.getElementById('m-guardrails').textContent = sumMetric(m, 'heartbit_reliability_guardrail_denials_total');
    document.getElementById('m-prunes').textContent = m['heartbit_reliability_session_prunes_total'] || 0;
    document.getElementById('m-summarizations').textContent = m['heartbit_reliability_context_summarizations_total'] || 0;

    // Agent stats (per-agent breakdown)
    const agents = extractLabel(m, 'heartbit_agent_runs_started_total', 'agent');
    const agentCompleted = extractLabel(m, 'heartbit_agent_runs_completed_total', 'agent');
    const agentDiv = document.getElementById('agent-stats');
    if (Object.keys(agents).length > 0) {
      agentDiv.innerHTML = Object.entries(agents)
        .sort((a,b) => b[1] - a[1])
        .map(([name, started]) => {
          const completed = agentCompleted[name] || 0;
          return `<div class="stat"><span class="stat-label"><span class="agent-pill">${name}</span></span><span class="stat-value">${completed}/${started}</span></div>`;
        }).join('');
    }

    // Tool stats (aggregated across agent label, grouped by tool_name)
    const tools = {};
    for (const [k, v] of Object.entries(m)) {
      const tm = k.match(/heartbit_tool_calls_total\{.*?tool_name="([^"]+)".*?\}/);
      if (tm) tools[tm[1]] = (tools[tm[1]] || 0) + v;
    }
    const toolDiv = document.getElementById('tool-stats');
    if (Object.keys(tools).length > 0) {
      toolDiv.innerHTML = Object.entries(tools)
        .sort((a,b) => b[1] - a[1])
        .map(([name, count]) => `<div class="stat"><span class="stat-label">${name}</span><span class="stat-value">${count}</span></div>`)
        .join('');
    }
  } catch(e) { /* daemon not reachable */ }
}

// --- Tasks polling ---
async function pollTasks() {
  try {
    const data = await fetch(BASE + '/tasks?limit=20').then(r => r.json());
    const tbody = document.getElementById('tasks-body');
    tbody.innerHTML = '';
    for (const t of (data.tasks || data || [])) {
      const stateClass = 'state-' + (t.state || 'pending').toLowerCase();
      const shortId = (t.id || '').substring(0, 8);
      const source = t.source || '?';
      const shortTask = (t.task || '').substring(0, 50) + ((t.task||'').length > 50 ? '...' : '');
      const tokens = (t.tokens_used?.input_tokens || 0) + (t.tokens_used?.output_tokens || 0);
      const cost = t.estimated_cost_usd ? '$' + t.estimated_cost_usd.toFixed(4) : '-';
      const row = document.createElement('tr');
      row.innerHTML = `<td>${shortId}</td><td><span class="source-badge ${source}">${source}</span></td><td class="${stateClass}">${t.state}</td><td>${shortTask}</td><td>${fmt(tokens)}</td><td>${cost}</td>`;
      row.style.cursor = 'pointer';
      row.onclick = () => subscribeToTask(t.id);
      tbody.appendChild(row);
    }
  } catch(e) {}
}

// --- SSE event subscription ---
function subscribeToTask(taskId) {
  if (sseConnections[taskId]) return; // already subscribed
  const evSource = new EventSource(BASE + '/tasks/' + taskId + '/events');
  sseConnections[taskId] = evSource;

  evSource.onmessage = (e) => {
    try {
      const evt = JSON.parse(e.data);
      addEvent(taskId, evt);
    } catch(err) {
      addEventRaw(taskId, e.data);
    }
  };
  evSource.onerror = () => {
    evSource.close();
    delete sseConnections[taskId];
  };
  addEventRaw(taskId, `subscribed to task ${taskId.substring(0,8)}`);
}

function addEvent(taskId, evt) {
  const log = document.getElementById('events-log');
  const ts = new Date().toLocaleTimeString();
  const shortId = taskId.substring(0, 8);
  const type = evt.type || 'unknown';
  const typeClass = type.toLowerCase().replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');

  let detail = '';
  if (type === 'LlmResponse' || type === 'llm_response') {
    detail = `${evt.latency_ms||'?'}ms | model: ${evt.model||'?'}`;
    if (evt.text) detail += ` | "${evt.text.substring(0,80)}..."`;
  } else if (type === 'ToolCallStarted' || type === 'tool_call_started') {
    detail = `${evt.tool_name||'?'}`;
  } else if (type === 'ToolCallCompleted' || type === 'tool_call_completed') {
    detail = `${evt.tool_name||'?'} ${evt.output ? '('+evt.output.substring(0,60)+'...)' : ''}`;
  } else if (type === 'TurnStarted' || type === 'turn_started') {
    detail = `turn ${evt.turn||'?'}/${evt.max_turns||'?'}`;
  } else if (type === 'RunCompleted' || type === 'run_completed') {
    detail = `tokens: ${evt.input_tokens||0}+${evt.output_tokens||0}`;
  } else if (type === 'RunFailed' || type === 'run_failed') {
    detail = evt.error || '';
  }

  const div = document.createElement('div');
  div.className = 'event';
  div.innerHTML = `<span class="ts">${ts}</span> <span class="type ${typeClass}">[${shortId}] ${type}</span><span class="detail">${detail}</span>`;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

function addEventRaw(taskId, text) {
  const log = document.getElementById('events-log');
  const ts = new Date().toLocaleTimeString();
  const div = document.createElement('div');
  div.className = 'event';
  div.innerHTML = `<span class="ts">${ts}</span> <span class="detail">${text}</span>`;
  log.appendChild(div);
  log.scrollTop = log.scrollHeight;
}

// --- Submit task ---
async function submitTask() {
  const input = document.getElementById('task-input');
  const task = input.value.trim();
  if (!task) return;
  input.value = '';

  try {
    const resp = await fetch(BASE + '/tasks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ task }),
    });
    const data = await resp.json();
    if (data.id) {
      addEventRaw('', `submitted task ${data.id.substring(0,8)}: "${task.substring(0,60)}"`);
      subscribeToTask(data.id);
    }
  } catch(e) {
    addEventRaw('', `submit failed: ${e.message}`);
  }
}

document.getElementById('task-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') submitTask();
});

// --- Sensor activity tracking ---
let prevSensorReceived = {};
function updateSensorActivity(received, dropped) {
  const log = document.getElementById('sensor-activity');
  const ts = new Date().toLocaleTimeString();
  for (const [name, count] of Object.entries(received)) {
    const prev = prevSensorReceived[name] || 0;
    if (count > prev) {
      const newEvents = count - prev;
      const drop = (dropped[name] || 0) - (prevSensorReceived['_drop_' + name] || 0);
      const prom = Math.max(0, newEvents - Math.max(0, drop));
      const div = document.createElement('div');
      div.className = 'sensor-event';
      div.innerHTML = `<span class="sensor-ts">${ts}</span> <span class="sensor-name">${name}</span> `
        + `<span class="sensor-content">+${newEvents} events</span>`
        + (prom > 0 ? `<span class="sensor-verdict promoted">${prom} promoted</span>` : '')
        + (drop > 0 ? `<span class="sensor-verdict dropped">${drop} filtered</span>` : '');
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
      // Keep max 50 entries
      while (log.children.length > 50) log.removeChild(log.firstChild);
    }
    prevSensorReceived[name] = count;
    prevSensorReceived['_drop_' + name] = dropped[name] || 0;
  }
}

// --- Polling loops ---
setInterval(pollHealth, 3000);
setInterval(pollMetrics, 2000);
setInterval(pollStats, 3000);
setInterval(pollTasks, 3000);
pollHealth();
pollMetrics();
pollStats();
pollTasks();
</script>
</body>
</html>
